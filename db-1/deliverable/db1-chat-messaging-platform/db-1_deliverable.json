{
  "database": {
    "id": "db-1",
    "name": "Database db-1",
    "description": "Database db-1",
    "created_date": "2026-02-09",
    "version": "1.0"
  },
  "schema": {
    "total_tables": 11,
    "tables": [
      {
        "name": "profiles",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "username",
            "data_type": "VARCHAR(255)",
            "constraints": "UNIQUE, NOT NULL",
            "description": ""
          },
          {
            "name": "email",
            "data_type": "VARCHAR(255)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "display_name",
            "data_type": "VARCHAR(255)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "chats",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "created_by",
            "data_type": "UUID",
            "constraints": "FOREIGN KEY",
            "description": ""
          },
          {
            "name": "title",
            "data_type": "VARCHAR(255)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "messages",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "chat_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "sender_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "is_ai",
            "data_type": "BOOLEAN",
            "constraints": "NOT NULL",
            "description": ""
          },
          {
            "name": "content",
            "data_type": "TEXT",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "chat_participants",
        "description": "",
        "columns": [
          {
            "name": "chat_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "user_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "joined_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          },
          {
            "name": "PRIMARY",
            "data_type": "KEY",
            "constraints": "PRIMARY KEY",
            "description": ""
          }
        ]
      },
      {
        "name": "friends",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "user_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "friend_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "status",
            "data_type": "VARCHAR(50)",
            "constraints": "NOT NULL",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "notifications",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "user_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "type",
            "data_type": "VARCHAR(100)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          },
          {
            "name": "read",
            "data_type": "BOOLEAN",
            "constraints": "",
            "description": ""
          },
          {
            "name": "seen_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "file_attachments",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "chat_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "user_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "file_name",
            "data_type": "VARCHAR(255)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "file_type",
            "data_type": "VARCHAR(100)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "file_size",
            "data_type": "BIGINT",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "anonymous_chats",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "join_code",
            "data_type": "VARCHAR(50)",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          },
          {
            "name": "expires_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "anonymous_chat_users",
        "description": "",
        "columns": [
          {
            "name": "guest_id",
            "data_type": "UUID",
            "constraints": "NOT NULL",
            "description": ""
          },
          {
            "name": "chat_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "PRIMARY",
            "data_type": "KEY",
            "constraints": "PRIMARY KEY",
            "description": ""
          }
        ]
      },
      {
        "name": "anonymous_messages",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "chat_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "guest_id",
            "data_type": "UUID",
            "constraints": "NOT NULL",
            "description": ""
          },
          {
            "name": "content",
            "data_type": "TEXT",
            "constraints": "",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          }
        ]
      },
      {
        "name": "chat_invitations",
        "description": "",
        "columns": [
          {
            "name": "id",
            "data_type": "UUID",
            "constraints": "PRIMARY KEY",
            "description": ""
          },
          {
            "name": "inviting_user_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "invited_user_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "chat_id",
            "data_type": "UUID",
            "constraints": "NOT NULL, FOREIGN KEY",
            "description": ""
          },
          {
            "name": "status",
            "data_type": "VARCHAR(50)",
            "constraints": "NOT NULL",
            "description": ""
          },
          {
            "name": "created_at",
            "data_type": "TIMESTAMP",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          },
          {
            "name": "CREATE",
            "data_type": "INDEX",
            "constraints": "",
            "description": ""
          }
        ]
      }
    ]
  },
  "queries": [
    {
      "number": 1,
      "title": "Multi-Window Time-Series Analysis with Rolling Aggregates",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for multi-window time-series analysis with rolling aggregates",
      "business_value": "Actionable insights from multi-window time-series analysis with rolling aggregates",
      "purpose": "Production multi-window time-series analysis with rolling aggregates analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 60\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(5) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 2,
      "title": "Segmentation Analysis with Decile Ranking",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for segmentation analysis with decile ranking",
      "business_value": "Actionable insights from segmentation analysis with decile ranking",
      "purpose": "Production segmentation analysis with decile ranking analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 5 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 70\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(6) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 3,
      "title": "Performance Quartile Distribution",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for performance quartile distribution",
      "business_value": "Actionable insights from performance quartile distribution",
      "purpose": "Production performance quartile distribution analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 80\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(7) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 4,
      "title": "Category Revenue Distribution Analysis",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for category revenue distribution analysis",
      "business_value": "Actionable insights from category revenue distribution analysis",
      "purpose": "Production category revenue distribution analysis analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 7 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 90\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(8) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 5,
      "title": "Velocity and Acceleration Metrics",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for velocity and acceleration metrics",
      "business_value": "Actionable insights from velocity and acceleration metrics",
      "purpose": "Production velocity and acceleration metrics analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 100\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(9) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 6,
      "title": "Hourly Pattern Detection and Clustering",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for hourly pattern detection and clustering",
      "business_value": "Actionable insights from hourly pattern detection and clustering",
      "purpose": "Production hourly pattern detection and clustering analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 110\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(4) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 7,
      "title": "Gap Analysis with Sequential Difference",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for gap analysis with sequential difference",
      "business_value": "Actionable insights from gap analysis with sequential difference",
      "purpose": "Production gap analysis with sequential difference analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 120\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(5) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 8,
      "title": "Anomaly Detection Using Z-Score Windows",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for anomaly detection using z-score windows",
      "business_value": "Actionable insights from anomaly detection using z-score windows",
      "purpose": "Production anomaly detection using z-score windows analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 130\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(6) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 9,
      "title": "Recency-Frequency Scoring Model",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for recency-frequency scoring model",
      "business_value": "Actionable insights from recency-frequency scoring model",
      "purpose": "Production recency-frequency scoring model analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 5 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 140\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(7) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 10,
      "title": "Multi-Period Cohort Retention Analysis",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for multi-period cohort retention analysis",
      "business_value": "Actionable insights from multi-period cohort retention analysis",
      "purpose": "Production multi-period cohort retention analysis analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 150\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(8) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 11,
      "title": "Second-Order Derivative Computation",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for second-order derivative computation",
      "business_value": "Actionable insights from second-order derivative computation",
      "purpose": "Production second-order derivative computation analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 7 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 160\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(9) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 12,
      "title": "Cross-Category Benchmarking with Percentiles",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for cross-category benchmarking with percentiles",
      "business_value": "Actionable insights from cross-category benchmarking with percentiles",
      "purpose": "Production cross-category benchmarking with percentiles analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 170\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(4) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 13,
      "title": "Weighted Moving Average Pipeline",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for weighted moving average pipeline",
      "business_value": "Actionable insights from weighted moving average pipeline",
      "purpose": "Production weighted moving average pipeline analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 180\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(5) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 14,
      "title": "Peak Period Identification and Efficiency",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for peak period identification and efficiency",
      "business_value": "Actionable insights from peak period identification and efficiency",
      "purpose": "Production peak period identification and efficiency analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 190\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(6) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 15,
      "title": "Lifetime Value Estimation Model",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for lifetime value estimation model",
      "business_value": "Actionable insights from lifetime value estimation model",
      "purpose": "Production lifetime value estimation model analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 200\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(7) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 16,
      "title": "Year-over-Year Growth Rate Analysis",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for year-over-year growth rate analysis",
      "business_value": "Actionable insights from year-over-year growth rate analysis",
      "purpose": "Production year-over-year growth rate analysis analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 5 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 210\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(8) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 17,
      "title": "Heatmap Data Generation by Dimensions",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for heatmap data generation by dimensions",
      "business_value": "Actionable insights from heatmap data generation by dimensions",
      "purpose": "Production heatmap data generation by dimensions analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 220\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(9) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 18,
      "title": "Running Percentile Distribution",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for running percentile distribution",
      "business_value": "Actionable insights from running percentile distribution",
      "purpose": "Production running percentile distribution analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 7 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 230\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(4) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 19,
      "title": "Cross-Correlation Pattern Analysis",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for cross-correlation pattern analysis",
      "business_value": "Actionable insights from cross-correlation pattern analysis",
      "purpose": "Production cross-correlation pattern analysis analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 240\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(5) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 20,
      "title": "Status Transition Forensic Analysis",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for status transition forensic analysis",
      "business_value": "Actionable insights from status transition forensic analysis",
      "purpose": "Production status transition forensic analysis analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 250\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(6) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 21,
      "title": "Multi-Metric Dashboard Aggregation",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for multi-metric dashboard aggregation",
      "business_value": "Actionable insights from multi-metric dashboard aggregation",
      "purpose": "Production multi-metric dashboard aggregation analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 260\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(7) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 22,
      "title": "Sequential Pattern Mining with Windows",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for sequential pattern mining with windows",
      "business_value": "Actionable insights from sequential pattern mining with windows",
      "purpose": "Production sequential pattern mining with windows analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 270\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(8) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 23,
      "title": "Concentration Index Computation",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for concentration index computation",
      "business_value": "Actionable insights from concentration index computation",
      "purpose": "Production concentration index computation analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 5 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 280\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(9) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 24,
      "title": "Statistical Anomaly Score Assignment",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for statistical anomaly score assignment",
      "business_value": "Actionable insights from statistical anomaly score assignment",
      "purpose": "Production statistical anomaly score assignment analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 290\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(4) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 25,
      "title": "Fiscal Period Comparative Reporting",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for fiscal period comparative reporting",
      "business_value": "Actionable insights from fiscal period comparative reporting",
      "purpose": "Production fiscal period comparative reporting analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 7 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 300\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(5) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 26,
      "title": "Throughput Optimization Metrics",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for throughput optimization metrics",
      "business_value": "Actionable insights from throughput optimization metrics",
      "purpose": "Production throughput optimization metrics analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 8 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 310\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(6) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 27,
      "title": "Cumulative Trend Analysis Pipeline",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for cumulative trend analysis pipeline",
      "business_value": "Actionable insights from cumulative trend analysis pipeline",
      "purpose": "Production cumulative trend analysis pipeline analysis",
      "complexity": "4 CTEs, 9 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 320\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(7) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 28,
      "title": "Multi-Dimensional Pivot Aggregation",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and month-level grouping.",
      "use_case": "Business analytics for multi-dimensional pivot aggregation",
      "business_value": "Actionable insights from multi-dimensional pivot aggregation",
      "purpose": "Production multi-dimensional pivot aggregation analysis",
      "complexity": "4 CTEs, 6 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by month and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 330\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(8) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('month', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('month', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 2\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 29,
      "title": "Funnel Stage Progression Tracking",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and day-level grouping.",
      "use_case": "Business analytics for funnel stage progression tracking",
      "business_value": "Actionable insights from funnel stage progression tracking",
      "purpose": "Production funnel stage progression tracking analysis",
      "complexity": "4 CTEs, 7 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by day and hex",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY hex ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.hex) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.hex ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 340\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.hex ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.hex) AS partition_stddev,\n        NTILE(9) OVER (PARTITION BY c2.hex ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.hex ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('day', c4.timestamp) AS period,\n    c4.hex,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('day', c4.timestamp), c4.hex\nHAVING COUNT(*) >= 3\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    },
    {
      "number": 30,
      "title": "Outlier Detection with IQR Method",
      "description": "Uses 4 CTEs with window functions, statistical aggregations, and week-level grouping.",
      "use_case": "Business analytics for outlier detection with iqr method",
      "business_value": "Actionable insights from outlier detection with iqr method",
      "purpose": "Production outlier detection with iqr method analysis",
      "complexity": "4 CTEs, 8 window functions, GROUP BY with HAVING, date arithmetic",
      "expected_output": "Aggregated metrics grouped by week and speed",
      "sql": "WITH cte_level_1 AS (\n    SELECT \n        *,\n        ROW_NUMBER() OVER (PARTITION BY speed ORDER BY timestamp DESC) AS rn,\n        DATE_TRUNC('day', timestamp) AS day_bucket,\n        DATE_TRUNC('week', timestamp) AS week_bucket,\n        EXTRACT(HOUR FROM timestamp) AS hour_val,\n        EXTRACT(DOW FROM timestamp) AS dow_val\n    FROM aircraft_position_history\n    WHERE timestamp >= CURRENT_TIMESTAMP - INTERVAL '365 days'\n),\ncte_level_2 AS (\n    SELECT\n        c1.*,\n        COUNT(*) OVER (PARTITION BY c1.day_bucket, c1.speed) AS daily_partition_count,\n        AVG(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN 5 PRECEDING AND CURRENT ROW) AS rolling_avg,\n        SUM(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sum,\n        FIRST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp) AS first_val,\n        LAST_VALUE(c1.altitude) OVER (PARTITION BY c1.speed ORDER BY c1.timestamp ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\n    FROM cte_level_1 c1\n    WHERE c1.rn <= 350\n),\ncte_level_3 AS (\n    SELECT\n        c2.*,\n        LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS prev_value,\n        LEAD(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS next_value,\n        c2.altitude - LAG(c2.altitude, 1) OVER (PARTITION BY c2.speed ORDER BY c2.timestamp) AS delta_value,\n        AVG(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_avg,\n        STDDEV(c2.altitude) OVER (PARTITION BY c2.speed) AS partition_stddev,\n        NTILE(4) OVER (PARTITION BY c2.speed ORDER BY c2.altitude) AS ntile_bucket,\n        RANK() OVER (PARTITION BY c2.day_bucket ORDER BY c2.altitude DESC) AS daily_rank\n    FROM cte_level_2 c2\n),\ncte_level_4 AS (\n    SELECT\n        c3.*,\n        CASE \n            WHEN c3.partition_stddev > 0 THEN (c3.altitude - c3.partition_avg) / c3.partition_stddev\n            ELSE 0 \n        END AS z_score,\n        DENSE_RANK() OVER (ORDER BY c3.cumulative_sum DESC) AS overall_rank,\n        PERCENT_RANK() OVER (PARTITION BY c3.speed ORDER BY c3.altitude) AS pct_rank,\n        CASE\n            WHEN c3.delta_value > 0 THEN 'Increasing'\n            WHEN c3.delta_value < 0 THEN 'Decreasing'\n            ELSE 'Stable'\n        END AS trend_direction\n    FROM cte_level_3 c3\n)\nSELECT\n    DATE_TRUNC('week', c4.timestamp) AS period,\n    c4.speed,\n    COUNT(*) AS record_count,\n    AVG(c4.altitude) AS avg_value,\n    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY c4.altitude) AS q1_value,\n    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY c4.altitude) AS median_value,\n    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY c4.altitude) AS q3_value,\n    STDDEV(c4.altitude) AS stddev_value,\n    MIN(c4.altitude) AS min_value,\n    MAX(c4.altitude) AS max_value,\n    SUM(CASE WHEN c4.z_score > 2 THEN 1 ELSE 0 END) AS outlier_count,\n    SUM(CASE WHEN c4.trend_direction = 'Increasing' THEN 1 ELSE 0 END) AS increasing_count,\n    AVG(c4.rolling_avg) AS avg_rolling,\n    MAX(c4.cumulative_sum) AS max_cumulative\nFROM cte_level_4 c4\nGROUP BY DATE_TRUNC('week', c4.timestamp), c4.speed\nHAVING COUNT(*) >= 1\nORDER BY period DESC, avg_value DESC\nLIMIT 100"
    }
  ],
  "metadata": {
    "total_queries": 30,
    "extraction_timestamp": "20260209-1500",
    "format_date": "20260210-0053"
  }
}