{
  "source_file": "/Users/machine/Documents/AQ/db/db-10/queries/queries.md",
  "extraction_timestamp": "20260205-1902",
  "total_queries": 30,
  "queries": [
    {
      "number": 1,
      "title": "Multi-Retailer Price Comparison with Geographic Filtering and Temporal Trend Analysis",
      "description": "Description: Analyzes pricing across multiple retailers for products within geographic markets, incorporating temporal trends, price volatility metrics, and competitive positioning. Uses multiple CTEs to aggregate pricing data, calculate price differences, identify best deals, and track price movements over time with window functions. Use Case: Competitive pricing analysis for retail intelligence platforms - identify best prices by location and track price trends over time Business Value: Enable",
      "complexity": "Deep nested CTEs (6+ levels), multiple joins across products/retailers/stores/pricing tables, window functions with frame clauses, percentile calculations, temporal aggregations, geographic filtering, correlated subqueries",
      "expected_output": "Product pricing comparison report showing best prices by retailer and location, price trends, and competitive positioning metrics",
      "sql": "WITH product_base_pricing AS (\n    -- First CTE: Base pricing data with product and retailer information\n    SELECT\n        pp.pricing_id,\n        pp.product_id,\n        pp.retailer_id,\n        pp.store_id,\n        p.product_name,\n        p.brand,\n        p.category,\n        p.subcategory,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_city,\n        s.store_state,\n        s.store_zip,\n        s.store_latitude,\n        s.store_longitude,\n        pp.current_price,\n        pp.original_price,\n        pp.sale_price,\n        pp.discount_percentage,\n        pp.price_effective_date,\n        pp.price_expiry_date,\n        pp.price_type,\n        pp.is_online_price,\n        pp.price_confidence_score\n    FROM product_pricing pp\n    INNER JOIN products p ON pp.product_id = p.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    WHERE pp.price_effective_date >= CURRENT_DATE - INTERVAL '90 days'\n        AND p.is_active = TRUE\n        AND r.retailer_status = 'active'\n),\ngeographic_market_mapping AS (\n    -- Second CTE: Map stores to geographic markets\n    SELECT\n        pbp.*,\n        gm.market_id,\n        gm.market_name,\n        gm.market_type,\n        gm.market_code,\n        gm.population,\n        gm.median_income,\n        CASE\n            WHEN gm.market_geom IS NOT NULL AND s.store_geom IS NOT NULL THEN\n                CASE\n                    WHEN ST_WITHIN(s.store_geom, gm.market_geom) THEN TRUE\n                    ELSE FALSE\n                END\n            WHEN gm.market_type = 'zip' AND s.store_zip = gm.market_code THEN TRUE\n            WHEN gm.market_type = 'city' AND s.store_city = gm.market_name AND s.store_state = gm.state_code THEN TRUE\n            WHEN gm.market_type = 'state' AND s.store_state = gm.state_code THEN TRUE\n            ELSE FALSE\n        END AS is_in_market\n    FROM product_base_pricing pbp\n    LEFT JOIN stores s ON pbp.store_id = s.store_id\n    LEFT JOIN geographic_markets gm ON (\n        (gm.market_type = 'zip' AND s.store_zip = gm.market_code)\n        OR (gm.market_type = 'city' AND s.store_city = gm.market_name AND s.store_state = gm.state_code)\n        OR (gm.market_type = 'state' AND s.store_state = gm.state_code)\n        OR (gm.market_geom IS NOT NULL AND s.store_geom IS NOT NULL AND ST_WITHIN(s.store_geom, gm.market_geom))\n    )\n    WHERE pbp.store_id IS NOT NULL OR pbp.is_online_price = TRUE\n),\nmarket_pricing_aggregates AS (\n    -- Third CTE: Aggregate pricing by market and product\n    SELECT\n        gmm.product_id,\n        gmm.product_name,\n        gmm.brand,\n        gmm.category,\n        gmm.market_id,\n        gmm.market_name,\n        gmm.market_type,\n        gmm.population,\n        gmm.median_income,\n        COUNT(DISTINCT gmm.retailer_id) AS retailer_count,\n        COUNT(DISTINCT gmm.store_id) AS store_count,\n        COUNT(DISTINCT CASE WHEN gmm.is_online_price = FALSE THEN gmm.store_id END) AS physical_store_count,\n        COUNT(DISTINCT CASE WHEN gmm.is_online_price = TRUE THEN gmm.retailer_id END) AS online_retailer_count,\n        MIN(gmm.current_price) AS min_price,\n        MAX(gmm.current_price) AS max_price,\n        AVG(gmm.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY gmm.current_price) AS median_price,\n        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY gmm.current_price) AS q1_price,\n        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY gmm.current_price) AS q3_price,\n        STDDEV(gmm.current_price) AS price_std_dev,\n        AVG(gmm.discount_percentage) AS avg_discount_percentage,\n        COUNT(CASE WHEN gmm.price_type = 'sale' THEN 1 END) AS sale_count,\n        COUNT(CASE WHEN gmm.price_type = 'clearance' THEN 1 END) AS clearance_count\n    FROM geographic_market_mapping gmm\n    WHERE gmm.is_in_market = TRUE OR gmm.is_online_price = TRUE\n    GROUP BY\n        gmm.product_id,\n        gmm.product_name,\n        gmm.brand,\n        gmm.category,\n        gmm.market_id,\n        gmm.market_name,\n        gmm.market_type,\n        gmm.population,\n        gmm.median_income\n),\nretailer_market_positioning AS (\n    -- Fourth CTE: Calculate retailer positioning within each market\n    SELECT\n        mpa.*,\n        gmm.retailer_id,\n        gmm.retailer_name,\n        gmm.retailer_type,\n        gmm.current_price AS retailer_price,\n        gmm.price_type AS retailer_price_type,\n        gmm.discount_percentage AS retailer_discount,\n        CASE\n            WHEN gmm.current_price = mpa.min_price THEN 'lowest'\n            WHEN gmm.current_price <= mpa.q1_price THEN 'low'\n            WHEN gmm.current_price <= mpa.median_price THEN 'below_median'\n            WHEN gmm.current_price <= mpa.q3_price THEN 'above_median'\n            WHEN gmm.current_price = mpa.max_price THEN 'highest'\n            ELSE 'high'\n        END AS price_position,\n        (gmm.current_price - mpa.min_price) AS price_difference_from_min,\n        ((gmm.current_price - mpa.min_price) / NULLIF(mpa.min_price, 0)) * 100 AS price_premium_percentage,\n        ROW_NUMBER() OVER (\n            PARTITION BY mpa.product_id, mpa.market_id\n            ORDER BY gmm.current_price ASC\n        ) AS price_rank\n    FROM market_pricing_aggregates mpa\n    INNER JOIN geographic_market_mapping gmm ON mpa.product_id = gmm.product_id\n        AND mpa.market_id = gmm.market_id\n    WHERE gmm.is_in_market = TRUE OR gmm.is_online_price = TRUE\n),\ntemporal_price_trends AS (\n    -- Fifth CTE: Analyze price trends over time with window functions\n    SELECT\n        rmp.*,\n        gmm.price_effective_date,\n        LAG(gmm.current_price, 1) OVER (\n            PARTITION BY rmp.product_id, rmp.retailer_id, rmp.market_id\n            ORDER BY gmm.price_effective_date\n        ) AS prev_price,\n        LEAD(gmm.current_price, 1) OVER (\n            PARTITION BY rmp.product_id, rmp.retailer_id, rmp.market_id\n            ORDER BY gmm.price_effective_date\n        ) AS next_price,\n        AVG(gmm.current_price) OVER (\n            PARTITION BY rmp.product_id, rmp.retailer_id, rmp.market_id\n            ORDER BY gmm.price_effective_date\n            ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_price_7d,\n        STDDEV(gmm.current_price) OVER (\n            PARTITION BY rmp.product_id, rmp.retailer_id, rmp.market_id\n            ORDER BY gmm.price_effective_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_30d,\n        MIN(gmm.current_price) OVER (\n            PARTITION BY rmp.product_id, rmp.retailer_id, rmp.market_id\n            ORDER BY gmm.price_effective_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS min_price_30d,\n        MAX(gmm.current_price) OVER (\n            PARTITION BY rmp.product_id, rmp.retailer_id, rmp.market_id\n            ORDER BY gmm.price_effective_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS max_price_30d\n    FROM retailer_market_positioning rmp\n    INNER JOIN geographic_market_mapping gmm ON rmp.product_id = gmm.product_id\n        AND rmp.retailer_id = gmm.retailer_id\n        AND rmp.market_id = gmm.market_id\n),\nfinal_price_intelligence AS (\n    -- Sixth CTE: Final analytics with comprehensive metrics\n    SELECT\n        tpt.product_id,\n        tpt.product_name,\n        tpt.brand,\n        tpt.category,\n        tpt.market_id,\n        tpt.market_name,\n        tpt.market_type,\n        tpt.population,\n        tpt.median_income,\n        tpt.retailer_id,\n        tpt.retailer_name,\n        tpt.retailer_type,\n        tpt.retailer_price,\n        tpt.price_position,\n        tpt.price_rank,\n        tpt.price_difference_from_min,\n        ROUND(CAST(tpt.price_premium_percentage AS NUMERIC), 2) AS price_premium_percentage,\n        tpt.retailer_price_type,\n        tpt.retailer_discount,\n        tpt.retailer_count,\n        tpt.store_count,\n        tpt.physical_store_count,\n        tpt.online_retailer_count,\n        tpt.min_price,\n        tpt.max_price,\n        ROUND(CAST(tpt.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(tpt.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(tpt.price_std_dev AS NUMERIC), 2) AS price_std_dev,\n        ROUND(CAST(tpt.avg_discount_percentage AS NUMERIC), 2) AS avg_discount_percentage,\n        tpt.sale_count,\n        tpt.clearance_count,\n        tpt.price_effective_date,\n        tpt.prev_price,\n        tpt.next_price,\n        CASE\n            WHEN tpt.prev_price IS NOT NULL THEN tpt.retailer_price - tpt.prev_price\n            ELSE NULL\n        END AS price_change,\n        CASE\n            WHEN tpt.prev_price IS NOT NULL AND tpt.prev_price != 0 THEN\n                ((tpt.retailer_price - tpt.prev_price) / tpt.prev_price) * 100\n            ELSE NULL\n        END AS price_change_percentage,\n        ROUND(CAST(tpt.moving_avg_price_7d AS NUMERIC), 2) AS moving_avg_price_7d,\n        ROUND(CAST(tpt.price_volatility_30d AS NUMERIC), 2) AS price_volatility_30d,\n        tpt.min_price_30d,\n        tpt.max_price_30d,\n        CASE\n            WHEN tpt.retailer_price <= tpt.min_price_30d THEN 'at_30d_low'\n            WHEN tpt.retailer_price >= tpt.max_price_30d THEN 'at_30d_high'\n            ELSE 'mid_range'\n        END AS price_position_30d\n    FROM temporal_price_trends tpt\n)\nSELECT\n    product_name,\n    brand,\n    category,\n    market_name,\n    market_type,\n    retailer_name,\n    retailer_type,\n    retailer_price,\n    price_position,\n    price_rank,\n    price_premium_percentage,\n    retailer_discount,\n    avg_price,\n    median_price,\n    min_price,\n    max_price,\n    price_change_percentage,\n    moving_avg_price_7d,\n    price_volatility_30d,\n    price_position_30d,\n    retailer_count,\n    store_count,\n    physical_store_count,\n    online_retailer_count\nFROM final_price_intelligence\nWHERE price_rank <= 5\nORDER BY\n    product_id,\n    market_id,\n    price_rank;",
      "line_number": 54
    },
    {
      "number": 2,
      "title": "Inventory Availability Prediction Using Historical Patterns and Geographic Distribution",
      "description": "Description: Predicts inventory availability by analyzing historical stock patterns, restocking frequencies, seasonal trends, and geographic distribution. Uses recursive CTEs for pattern detection, window functions for trend analysis, and complex aggregations to forecast stock levels. Use Case: Inventory forecasting for retail operations - predict when products will be in stock and optimize restocking schedules Business Value: Enables retailers to optimize inventory management, reduce stockouts,",
      "complexity": "Recursive CTEs for pattern detection, multiple CTEs (7+ levels), window functions with complex frame clauses, temporal aggregations, geographic clustering, statistical forecasting calculations",
      "expected_output": "Inventory availability predictions with confidence scores, restocking recommendations, and geographic distribution analysis",
      "sql": "WITH RECURSIVE inventory_history AS (\n    -- Base case: Current inventory state\n    SELECT\n        pi.inventory_id,\n        pi.product_id,\n        pi.store_id,\n        pi.stock_level,\n        pi.stock_status,\n        pi.available_quantity,\n        pi.last_checked_at,\n        pi.last_restocked_at,\n        p.product_name,\n        p.category,\n        s.store_city,\n        s.store_state,\n        s.retailer_id,\n        r.retailer_name,\n        DATE_TRUNC('day', pi.last_checked_at) AS check_date,\n        EXTRACT(DOW FROM pi.last_checked_at) AS day_of_week,\n        EXTRACT(MONTH FROM pi.last_checked_at) AS month_num\n    FROM product_inventory pi\n    INNER JOIN products p ON pi.product_id = p.product_id\n    INNER JOIN stores s ON pi.store_id = s.store_id\n    INNER JOIN retailers r ON s.retailer_id = r.retailer_id\n    WHERE pi.last_checked_at >= CURRENT_TIMESTAMP - INTERVAL '180 days'\n        AND p.is_active = TRUE\n    \n    UNION ALL\n    \n    -- Recursive case: Historical inventory states (simulated from check history)\n    SELECT\n        ih.inventory_id,\n        ih.product_id,\n        ih.store_id,\n        CASE\n            WHEN ih.stock_status = 'out_of_stock' AND ih.last_restocked_at IS NOT NULL THEN\n                CASE\n                    WHEN ih.last_restocked_at > ih.last_checked_at - INTERVAL '7 days' THEN 50\n                    ELSE 0\n                END\n            ELSE ih.stock_level\n        END AS stock_level,\n        ih.stock_status,\n        ih.available_quantity,\n        ih.last_checked_at - INTERVAL '1 day' AS last_checked_at,\n        ih.last_restocked_at,\n        ih.product_name,\n        ih.category,\n        ih.store_city,\n        ih.store_state,\n        ih.retailer_id,\n        ih.retailer_name,\n        DATE_TRUNC('day', ih.last_checked_at - INTERVAL '1 day') AS check_date,\n        EXTRACT(DOW FROM ih.last_checked_at - INTERVAL '1 day') AS day_of_week,\n        EXTRACT(MONTH FROM ih.last_checked_at - INTERVAL '1 day') AS month_num\n    FROM inventory_history ih\n    WHERE ih.last_checked_at > CURRENT_TIMESTAMP - INTERVAL '180 days'\n),\ninventory_patterns AS (\n    -- Second CTE: Identify inventory patterns and cycles\n    SELECT\n        product_id,\n        store_id,\n        product_name,\n        category,\n        store_city,\n        store_state,\n        retailer_id,\n        retailer_name,\n        check_date,\n        day_of_week,\n        month_num,\n        stock_level,\n        stock_status,\n        available_quantity,\n        last_checked_at,\n        last_restocked_at,\n        COUNT(*) OVER (\n            PARTITION BY product_id, store_id\n            ORDER BY check_date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS days_tracked,\n        LAG(stock_level, 1) OVER (\n            PARTITION BY product_id, store_id\n            ORDER BY check_date\n        ) AS prev_stock_level,\n        LAG(stock_status, 1) OVER (\n            PARTITION BY product_id, store_id\n            ORDER BY check_date\n        ) AS prev_stock_status,\n        CASE\n            WHEN stock_status = 'out_of_stock' AND LAG(stock_status, 1) OVER (\n                PARTITION BY product_id, store_id ORDER BY check_date\n            ) != 'out_of_stock' THEN 1\n            ELSE 0\n        END AS stockout_event,\n        CASE\n            WHEN stock_status != 'out_of_stock' AND LAG(stock_status, 1) OVER (\n                PARTITION BY product_id, store_id ORDER BY check_date\n            ) = 'out_of_stock' THEN 1\n            ELSE 0\n        END AS restock_event\n    FROM inventory_history\n),\nstockout_analysis AS (\n    -- Third CTE: Analyze stockout patterns and durations\n    SELECT\n        ip.*,\n        SUM(ip.stockout_event) OVER (\n            PARTITION BY ip.product_id, ip.store_id\n            ORDER BY ip.check_date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS stockout_count_cumulative,\n        SUM(ip.restock_event) OVER (\n            PARTITION BY ip.product_id, ip.store_id\n            ORDER BY ip.check_date\n            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        ) AS restock_count_cumulative,\n        CASE\n            WHEN ip.stockout_event = 1 THEN\n                ROW_NUMBER() OVER (\n                    PARTITION BY ip.product_id, ip.store_id, ip.stockout_event\n                    ORDER BY ip.check_date\n                )\n            ELSE NULL\n        END AS stockout_period_id\n    FROM inventory_patterns ip\n),\nstockout_durations AS (\n    -- Fourth CTE: Calculate stockout durations\n    SELECT\n        sa.*,\n        CASE\n            WHEN sa.stockout_period_id IS NOT NULL THEN\n                COUNT(*) OVER (\n                    PARTITION BY sa.product_id, sa.store_id, sa.stockout_period_id\n                )\n            ELSE NULL\n        END AS stockout_duration_days,\n        AVG(sa.stock_level) OVER (\n            PARTITION BY sa.product_id, sa.store_id\n            ORDER BY sa.check_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS avg_stock_30d,\n        STDDEV(sa.stock_level) OVER (\n            PARTITION BY sa.product_id, sa.store_id\n            ORDER BY sa.check_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS stock_volatility_30d,\n        MIN(sa.stock_level) OVER (\n            PARTITION BY sa.product_id, sa.store_id\n            ORDER BY sa.check_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS min_stock_30d,\n        MAX(sa.stock_level) OVER (\n            PARTITION BY sa.product_id, sa.store_id\n            ORDER BY sa.check_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS max_stock_30d\n    FROM stockout_analysis sa\n),\nseasonal_patterns AS (\n    -- Fifth CTE: Identify seasonal and weekly patterns\n    SELECT\n        sd.*,\n        AVG(sd.stock_level) OVER (\n            PARTITION BY sd.product_id, sd.store_id, sd.day_of_week\n        ) AS avg_stock_by_dow,\n        AVG(sd.stock_level) OVER (\n            PARTITION BY sd.product_id, sd.store_id, sd.month_num\n        ) AS avg_stock_by_month,\n        COUNT(CASE WHEN sd.stock_status = 'out_of_stock' THEN 1 END) OVER (\n            PARTITION BY sd.product_id, sd.store_id, sd.day_of_week\n        ) AS stockout_count_by_dow,\n        COUNT(CASE WHEN sd.stock_status = 'out_of_stock' THEN 1 END) OVER (\n            PARTITION BY sd.product_id, sd.store_id, sd.month_num\n        ) AS stockout_count_by_month\n    FROM stockout_durations sd\n),\ngeographic_clustering AS (\n    -- Sixth CTE: Analyze geographic distribution patterns\n    SELECT\n        sp.*,\n        COUNT(DISTINCT sp.store_id) OVER (\n            PARTITION BY sp.product_id, sp.store_state\n        ) AS store_count_by_state,\n        AVG(sp.stock_level) OVER (\n            PARTITION BY sp.product_id, sp.store_state\n        ) AS avg_stock_by_state,\n        COUNT(CASE WHEN sp.stock_status = 'out_of_stock' THEN 1 END) OVER (\n            PARTITION BY sp.product_id, sp.store_state\n        ) AS stockout_count_by_state,\n        COUNT(DISTINCT sp.store_id) OVER (\n            PARTITION BY sp.product_id, sp.store_city, sp.store_state\n        ) AS store_count_by_city,\n        AVG(sp.stock_level) OVER (\n            PARTITION BY sp.product_id, sp.store_city, sp.store_state\n        ) AS avg_stock_by_city\n    FROM seasonal_patterns sp\n),\navailability_prediction AS (\n    -- Seventh CTE: Generate availability predictions\n    SELECT\n        gc.product_id,\n        gc.product_name,\n        gc.category,\n        gc.store_id,\n        gc.store_city,\n        gc.store_state,\n        gc.retailer_id,\n        gc.retailer_name,\n        gc.check_date,\n        gc.stock_level,\n        gc.stock_status,\n        gc.available_quantity,\n        gc.avg_stock_30d,\n        gc.stock_volatility_30d,\n        gc.min_stock_30d,\n        gc.max_stock_30d,\n        gc.avg_stock_by_dow,\n        gc.avg_stock_by_month,\n        gc.stockout_count_by_dow,\n        gc.stockout_count_by_month,\n        gc.store_count_by_state,\n        gc.avg_stock_by_state,\n        gc.stockout_count_by_state,\n        gc.store_count_by_city,\n        gc.avg_stock_by_city,\n        -- Prediction calculations\n        CASE\n            WHEN gc.stock_level > gc.avg_stock_30d + (gc.stock_volatility_30d * 2) THEN 'high'\n            WHEN gc.stock_level < gc.avg_stock_30d - (gc.stock_volatility_30d * 2) THEN 'low'\n            ELSE 'normal'\n        END AS stock_level_classification,\n        CASE\n            WHEN gc.stock_status = 'out_of_stock' THEN\n                CASE\n                    WHEN gc.stockout_duration_days > 7 THEN 'extended_outage'\n                    WHEN gc.stockout_duration_days > 3 THEN 'moderate_outage'\n                    ELSE 'short_outage'\n                END\n            ELSE 'in_stock'\n        END AS outage_severity,\n        -- Forecast next 7 days availability\n        CASE\n            WHEN gc.stock_level > 0 AND gc.stock_level > gc.avg_stock_by_dow THEN 'likely_available'\n            WHEN gc.stock_level = 0 AND gc.stockout_count_by_dow < 2 THEN 'possibly_available'\n            ELSE 'unlikely_available'\n        END AS next_7d_availability_prediction,\n        -- Confidence score\n        CASE\n            WHEN gc.days_tracked >= 90 AND gc.stock_volatility_30d < 10 THEN 0.95\n            WHEN gc.days_tracked >= 60 AND gc.stock_volatility_30d < 20 THEN 0.85\n            WHEN gc.days_tracked >= 30 THEN 0.75\n            ELSE 0.60\n        END AS prediction_confidence\n    FROM geographic_clustering gc\n)\nSELECT\n    product_name,\n    category,\n    store_city,\n    store_state,\n    retailer_name,\n    check_date,\n    stock_level,\n    stock_status,\n    stock_level_classification,\n    outage_severity,\n    next_7d_availability_prediction,\n    ROUND(CAST(prediction_confidence AS NUMERIC), 2) AS prediction_confidence,\n    ROUND(CAST(avg_stock_30d AS NUMERIC), 0) AS avg_stock_30d,\n    ROUND(CAST(stock_volatility_30d AS NUMERIC), 2) AS stock_volatility_30d,\n    avg_stock_by_dow,\n    avg_stock_by_month,\n    store_count_by_state,\n    avg_stock_by_state\nFROM availability_prediction\nWHERE check_date >= CURRENT_DATE - INTERVAL '7 days'\nORDER BY\n    product_id,\n    store_id,\n    check_date DESC;",
      "line_number": 332
    },
    {
      "number": 3,
      "title": "Market Share Analysis with Competitive Positioning and Temporal Trends",
      "description": "Description: Analyzes market share by retailer and product category, incorporating competitive positioning metrics, temporal trends, and geographic distribution. Uses multiple CTEs to calculate market share percentages, competitive rankings, share changes over time, and market concentration metrics with window functions. Use Case: Competitive market analysis for retail intelligence - identify market leaders, track share changes, and analyze competitive dynamics Business Value: Enables retailers ",
      "complexity": "Multiple CTEs (6+ levels), complex aggregations, window functions with frame clauses, percentile rankings, temporal comparisons, market concentration calculations",
      "expected_output": "Market share report showing retailer rankings, share percentages, competitive positioning, and temporal trends by product category",
      "sql": "WITH retailer_product_sales AS (\n    SELECT\n        r.retailer_id,\n        r.retailer_name,\n        r.retailer_type,\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        COUNT(DISTINCT pp.pricing_id) AS pricing_records_count,\n        AVG(pp.current_price) AS avg_price,\n        COUNT(DISTINCT pp.store_id) AS store_count,\n        COUNT(DISTINCT CASE WHEN pi.stock_status = 'in_stock' THEN pi.store_id END) AS stores_in_stock,\n        SUM(CASE WHEN pi.stock_level > 0 THEN 1 ELSE 0 END) AS inventory_units\n    FROM retailers r\n    INNER JOIN product_pricing pp ON r.retailer_id = pp.retailer_id\n    INNER JOIN products p ON pp.product_id = p.product_id\n    LEFT JOIN product_inventory pi ON pp.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE r.retailer_status = 'active' AND p.is_active = TRUE\n    GROUP BY r.retailer_id, r.retailer_name, r.retailer_type, p.product_id, p.product_name, p.category, p.subcategory\n),\ncategory_market_totals AS (\n    SELECT\n        category,\n        subcategory,\n        COUNT(DISTINCT retailer_id) AS total_retailers,\n        COUNT(DISTINCT product_id) AS total_products,\n        SUM(pricing_records_count) AS total_pricing_records,\n        SUM(store_count) AS total_stores,\n        SUM(stores_in_stock) AS total_stores_in_stock,\n        SUM(inventory_units) AS total_inventory_units\n    FROM retailer_product_sales\n    GROUP BY category, subcategory\n),\nretailer_category_share AS (\n    SELECT\n        rps.*,\n        cmt.total_retailers,\n        cmt.total_products,\n        cmt.total_pricing_records,\n        cmt.total_stores,\n        cmt.total_stores_in_stock,\n        cmt.total_inventory_units,\n        CASE\n            WHEN cmt.total_pricing_records > 0 THEN\n                (rps.pricing_records_count::NUMERIC / cmt.total_pricing_records::NUMERIC) * 100\n            ELSE 0\n        END AS pricing_records_share,\n        CASE\n            WHEN cmt.total_stores > 0 THEN\n                (rps.store_count::NUMERIC / cmt.total_stores::NUMERIC) * 100\n            ELSE 0\n        END AS store_count_share,\n        CASE\n            WHEN cmt.total_stores_in_stock > 0 THEN\n                (rps.stores_in_stock::NUMERIC / cmt.total_stores_in_stock::NUMERIC) * 100\n            ELSE 0\n        END AS availability_share,\n        CASE\n            WHEN cmt.total_inventory_units > 0 THEN\n                (rps.inventory_units::NUMERIC / cmt.total_inventory_units::NUMERIC) * 100\n            ELSE 0\n        END AS inventory_share\n    FROM retailer_product_sales rps\n    INNER JOIN category_market_totals cmt ON rps.category = cmt.category AND rps.subcategory = cmt.subcategory\n),\nmarket_share_rankings AS (\n    SELECT\n        rcs.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY rcs.category, rcs.subcategory\n            ORDER BY rcs.pricing_records_share DESC\n        ) AS pricing_rank,\n        ROW_NUMBER() OVER (\n            PARTITION BY rcs.category, rcs.subcategory\n            ORDER BY rcs.store_count_share DESC\n        ) AS store_rank,\n        ROW_NUMBER() OVER (\n            PARTITION BY rcs.category, rcs.subcategory\n            ORDER BY rcs.availability_share DESC\n        ) AS availability_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY rcs.category, rcs.subcategory\n            ORDER BY rcs.pricing_records_share DESC\n        ) AS pricing_percentile,\n        NTILE(4) OVER (\n            PARTITION BY rcs.category, rcs.subcategory\n            ORDER BY rcs.pricing_records_share DESC\n        ) AS market_position_quartile\n    FROM retailer_category_share rcs\n),\ntemporal_share_analysis AS (\n    SELECT\n        msr.*,\n        pp.price_effective_date,\n        LAG(msr.pricing_records_share, 1) OVER (\n            PARTITION BY msr.retailer_id, msr.product_id\n            ORDER BY pp.price_effective_date\n        ) AS prev_pricing_share,\n        AVG(msr.pricing_records_share) OVER (\n            PARTITION BY msr.retailer_id, msr.product_id\n            ORDER BY pp.price_effective_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_share_30d,\n        STDDEV(msr.pricing_records_share) OVER (\n            PARTITION BY msr.retailer_id, msr.product_id\n            ORDER BY pp.price_effective_date\n            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW\n        ) AS share_volatility_90d\n    FROM market_share_rankings msr\n    INNER JOIN product_pricing pp ON msr.retailer_id = pp.retailer_id AND msr.product_id = pp.product_id\n),\nmarket_concentration AS (\n    SELECT\n        tsa.category,\n        tsa.subcategory,\n        COUNT(DISTINCT tsa.retailer_id) AS retailer_count,\n        SUM(tsa.pricing_records_share) AS total_share,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY tsa.pricing_records_share) AS median_share,\n        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY tsa.pricing_records_share) AS q1_share,\n        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY tsa.pricing_records_share) AS q3_share,\n        -- Herfindahl-Hirschman Index (HHI) for market concentration\n        SUM(POWER(tsa.pricing_records_share / 100.0, 2)) * 10000 AS hhi_index,\n        CASE\n            WHEN SUM(POWER(tsa.pricing_records_share / 100.0, 2)) * 10000 > 2500 THEN 'highly_concentrated'\n            WHEN SUM(POWER(tsa.pricing_records_share / 100.0, 2)) * 10000 > 1500 THEN 'moderately_concentrated'\n            ELSE 'competitive'\n        END AS concentration_level\n    FROM temporal_share_analysis tsa\n    GROUP BY tsa.category, tsa.subcategory\n),\nfinal_market_share_intelligence AS (\n    SELECT\n        tsa.retailer_id,\n        tsa.retailer_name,\n        tsa.retailer_type,\n        tsa.product_id,\n        tsa.product_name,\n        tsa.category,\n        tsa.subcategory,\n        ROUND(CAST(tsa.pricing_records_share AS NUMERIC), 2) AS pricing_records_share,\n        ROUND(CAST(tsa.store_count_share AS NUMERIC), 2) AS store_count_share,\n        ROUND(CAST(tsa.availability_share AS NUMERIC), 2) AS availability_share,\n        ROUND(CAST(tsa.inventory_share AS NUMERIC), 2) AS inventory_share,\n        tsa.pricing_rank,\n        tsa.store_rank,\n        tsa.availability_rank,\n        ROUND(CAST(tsa.pricing_percentile * 100 AS NUMERIC), 2) AS pricing_percentile,\n        tsa.market_position_quartile,\n        CASE\n            WHEN tsa.prev_pricing_share IS NOT NULL THEN\n                tsa.pricing_records_share - tsa.prev_pricing_share\n            ELSE NULL\n        END AS share_change,\n        CASE\n            WHEN tsa.prev_pricing_share IS NOT NULL AND tsa.prev_pricing_share != 0 THEN\n                ((tsa.pricing_records_share - tsa.prev_pricing_share) / tsa.prev_pricing_share) * 100\n            ELSE NULL\n        END AS share_change_percentage,\n        ROUND(CAST(tsa.moving_avg_share_30d AS NUMERIC), 2) AS moving_avg_share_30d,\n        ROUND(CAST(tsa.share_volatility_90d AS NUMERIC), 2) AS share_volatility_90d,\n        mc.hhi_index,\n        mc.concentration_level,\n        CASE\n            WHEN tsa.pricing_rank = 1 THEN 'market_leader'\n            WHEN tsa.pricing_rank <= 3 THEN 'top_3'\n            WHEN tsa.pricing_rank <= 5 THEN 'top_5'\n            ELSE 'other'\n        END AS competitive_position\n    FROM temporal_share_analysis tsa\n    INNER JOIN market_concentration mc ON tsa.category = mc.category AND tsa.subcategory = mc.subcategory\n)\nSELECT\n    retailer_name,\n    retailer_type,\n    product_name,\n    category,\n    subcategory,\n    pricing_records_share,\n    store_count_share,\n    availability_share,\n    inventory_share,\n    pricing_rank,\n    competitive_position,\n    share_change_percentage,\n    moving_avg_share_30d,\n    share_volatility_90d,\n    hhi_index,\n    concentration_level\nFROM final_market_share_intelligence\nWHERE pricing_rank <= 10\nORDER BY category, subcategory, pricing_rank;",
      "line_number": 633
    },
    {
      "number": 4,
      "title": "Deal Detection and Alert Generation with Temporal Patterns",
      "description": "Description: Detects deals and generates alerts by analyzing price changes, discount patterns, and temporal trends. Uses recursive CTEs for pattern detection, window functions for trend analysis, and complex aggregations to identify optimal deals. Use Case: Automated deal detection for retail intelligence platforms Business Value: Enables consumers and retailers to identify best deals automatically, supporting $1M+ ARR deal aggregation platforms Purpose: Provides comprehensive analysis for marke",
      "complexity": "Recursive CTEs, multiple CTEs (7+ levels), window functions with frame clauses, temporal pattern detection, discount analysis",
      "expected_output": "Detailed analysis report with metrics and insights",
      "sql": "WITH RECURSIVE deal_price_history AS (\n    -- Base case: Current deal pricing\n    SELECT\n        da.deal_id,\n        da.product_id,\n        da.retailer_id,\n        da.store_id,\n        da.deal_type,\n        da.discount_percentage,\n        da.deal_price,\n        da.original_price,\n        da.deal_start_date,\n        da.deal_end_date,\n        da.deal_status,\n        p.product_name,\n        p.category,\n        r.retailer_name,\n        s.store_city,\n        s.store_state,\n        DATE_TRUNC('day', da.deal_start_date) AS deal_date,\n        EXTRACT(DOW FROM da.deal_start_date) AS day_of_week\n    FROM deal_alerts da\n    INNER JOIN products p ON da.product_id = p.product_id\n    INNER JOIN retailers r ON da.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON da.store_id = s.store_id\n    WHERE da.deal_status = 'active'\n        AND p.is_active = TRUE\n    \n    UNION ALL\n    \n    -- Recursive case: Historical price patterns\n    SELECT\n        dph.deal_id,\n        dph.product_id,\n        dph.retailer_id,\n        dph.store_id,\n        dph.deal_type,\n        dph.discount_percentage,\n        dph.deal_price,\n        dph.original_price,\n        dph.deal_start_date - INTERVAL '1 day' AS deal_start_date,\n        dph.deal_end_date,\n        dph.deal_status,\n        dph.product_name,\n        dph.category,\n        dph.retailer_name,\n        dph.store_city,\n        dph.store_state,\n        DATE_TRUNC('day', dph.deal_start_date - INTERVAL '1 day') AS deal_date,\n        EXTRACT(DOW FROM dph.deal_start_date - INTERVAL '1 day') AS day_of_week\n    FROM deal_price_history dph\n    WHERE dph.deal_start_date > CURRENT_DATE - INTERVAL '180 days'\n),\nprice_change_detection AS (\n    -- Second CTE: Detect price changes and deal triggers\n    SELECT\n        dph.*,\n        pp.current_price AS current_market_price,\n        pp.price_effective_date,\n        CASE\n            WHEN pp.current_price < dph.deal_price THEN 'better_deal_available'\n            WHEN pp.current_price = dph.deal_price THEN 'price_match'\n            ELSE 'deal_better'\n        END AS price_comparison,\n        ABS(pp.current_price - dph.deal_price) AS price_difference,\n        CASE\n            WHEN dph.deal_price < pp.current_price THEN\n                ((pp.current_price - dph.deal_price) / pp.current_price) * 100\n            ELSE NULL\n        END AS savings_percentage\n    FROM deal_price_history dph\n    LEFT JOIN product_pricing pp ON dph.product_id = pp.product_id\n        AND dph.retailer_id = pp.retailer_id\n        AND pp.price_effective_date BETWEEN dph.deal_start_date AND COALESCE(dph.deal_end_date, CURRENT_DATE)\n),\ndeal_pattern_analysis AS (\n    -- Third CTE: Analyze deal patterns and frequencies\n    SELECT\n        pcd.*,\n        COUNT(*) OVER (\n            PARTITION BY pcd.product_id, pcd.retailer_id\n            ORDER BY pcd.deal_date\n            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW\n        ) AS deals_count_90d,\n        AVG(pcd.discount_percentage) OVER (\n            PARTITION BY pcd.product_id, pcd.retailer_id\n            ORDER BY pcd.deal_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS avg_discount_30d,\n        LAG(pcd.deal_price, 1) OVER (\n            PARTITION BY pcd.product_id, pcd.retailer_id\n            ORDER BY pcd.deal_date\n        ) AS prev_deal_price,\n        LEAD(pcd.deal_price, 1) OVER (\n            PARTITION BY pcd.product_id, pcd.retailer_id\n            ORDER BY pcd.deal_date\n        ) AS next_deal_price,\n        MIN(pcd.deal_price) OVER (\n            PARTITION BY pcd.product_id, pcd.retailer_id\n            ORDER BY pcd.deal_date\n            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW\n        ) AS min_deal_price_90d,\n        MAX(pcd.deal_price) OVER (\n            PARTITION BY pcd.product_id, pcd.retailer_id\n            ORDER BY pcd.deal_date\n            ROWS BETWEEN 89 PRECEDING AND CURRENT ROW\n        ) AS max_deal_price_90d\n    FROM price_change_detection pcd\n),\ndeal_alert_scoring AS (\n    -- Fourth CTE: Score deals for alert generation\n    SELECT\n        dpa.*,\n        CASE\n            WHEN dpa.prev_deal_price IS NOT NULL THEN\n                dpa.deal_price - dpa.prev_deal_price\n            ELSE NULL\n        END AS price_change_from_prev,\n        CASE\n            WHEN dpa.deal_price <= dpa.min_deal_price_90d * 1.05 THEN 'best_price_90d'\n            WHEN dpa.deal_price <= dpa.min_deal_price_90d * 1.15 THEN 'near_best_price'\n            ELSE 'regular_deal'\n        END AS deal_quality,\n        CASE\n            WHEN dpa.discount_percentage >= 50 THEN 100\n            WHEN dpa.discount_percentage >= 30 THEN 80\n            WHEN dpa.discount_percentage >= 20 THEN 60\n            WHEN dpa.discount_percentage >= 10 THEN 40\n            ELSE 20\n        END AS discount_score,\n        CASE\n            WHEN dpa.deals_count_90d <= 2 THEN 100\n            WHEN dpa.deals_count_90d <= 5 THEN 80\n            WHEN dpa.deals_count_90d <= 10 THEN 60\n            ELSE 40\n        END AS rarity_score,\n        CASE\n            WHEN dpa.savings_percentage >= 30 THEN 100\n            WHEN dpa.savings_percentage >= 20 THEN 80\n            WHEN dpa.savings_percentage >= 10 THEN 60\n            ELSE 40\n        END AS savings_score\n    FROM deal_pattern_analysis dpa\n),\ntemporal_deal_trends AS (\n    -- Fifth CTE: Analyze temporal trends\n    SELECT\n        das.*,\n        AVG(das.deal_price) OVER (\n            PARTITION BY das.product_id, das.day_of_week\n        ) AS avg_price_by_dow,\n        AVG(das.deal_price) OVER (\n            PARTITION BY das.product_id, EXTRACT(MONTH FROM das.deal_date)\n        ) AS avg_price_by_month,\n        COUNT(CASE WHEN das.deal_type = 'clearance' THEN 1 END) OVER (\n            PARTITION BY das.product_id\n            ORDER BY das.deal_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS clearance_count_30d,\n        COUNT(CASE WHEN das.deal_type = 'sale' THEN 1 END) OVER (\n            PARTITION BY das.product_id\n            ORDER BY das.deal_date\n            ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n        ) AS sale_count_30d\n    FROM deal_alert_scoring das\n),\nfinal_deal_intelligence AS (\n    -- Sixth CTE: Final deal intelligence with comprehensive metrics\n    SELECT\n        tdt.product_id,\n        tdt.product_name,\n        tdt.category,\n        tdt.retailer_id,\n        tdt.retailer_name,\n        tdt.store_city,\n        tdt.store_state,\n        tdt.deal_id,\n        tdt.deal_type,\n        tdt.deal_price,\n        tdt.original_price,\n        ROUND(CAST(tdt.discount_percentage AS NUMERIC), 2) AS discount_percentage,\n        tdt.deal_start_date,\n        tdt.deal_end_date,\n        tdt.deal_quality,\n        ROUND(CAST((tdt.discount_score + tdt.rarity_score + tdt.savings_score) / 3.0 AS NUMERIC), 2) AS overall_deal_score,\n        tdt.price_comparison,\n        ROUND(CAST(tdt.savings_percentage AS NUMERIC), 2) AS savings_percentage,\n        ROUND(CAST(tdt.avg_discount_30d AS NUMERIC), 2) AS avg_discount_30d,\n        tdt.deals_count_90d,\n        tdt.clearance_count_30d,\n        tdt.sale_count_30d,\n        CASE\n            WHEN (tdt.discount_score + tdt.rarity_score + tdt.savings_score) / 3.0 >= 80 THEN 'high_priority_alert'\n            WHEN (tdt.discount_score + tdt.rarity_score + tdt.savings_score) / 3.0 >= 60 THEN 'medium_priority_alert'\n            ELSE 'low_priority_alert'\n        END AS alert_priority\n    FROM temporal_deal_trends tdt\n)\nSELECT\n    product_name,\n    category,\n    retailer_name,\n    store_city,\n    store_state,\n    deal_type,\n    deal_price,\n    original_price,\n    discount_percentage,\n    deal_start_date,\n    deal_end_date,\n    deal_quality,\n    overall_deal_score,\n    alert_priority,\n    savings_percentage,\n    avg_discount_30d,\n    deals_count_90d\nFROM final_deal_intelligence\nWHERE overall_deal_score >= 60\nORDER BY overall_deal_score DESC, deal_start_date DESC;",
      "line_number": 846
    },
    {
      "number": 5,
      "title": "Product Category Trend Analysis with Seasonal Decomposition",
      "description": "Description: Analyzes product category trends with seasonal decomposition, identifying cyclical patterns, growth trends, and category performance metrics. Uses multiple CTEs for trend decomposition, window functions for seasonal analysis, and statistical calculations. Use Case: Category performance analysis for retail strategy Business Value: Enables retailers to understand category trends and optimize product mix, supporting $1M+ ARR retail analytics platforms Purpose: Provides comprehensive an",
      "complexity": "Multiple CTEs (8+ levels), seasonal decomposition, window functions with RANGE frames, trend analysis, statistical calculations",
      "expected_output": "Detailed analysis report with metrics and insights",
      "sql": "WITH category_sales_base AS (\n    SELECT\n        p.category,\n        p.subcategory,\n        p.product_id,\n        p.product_name,\n        pp.price_effective_date,\n        DATE_TRUNC('month', pp.price_effective_date) AS sale_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num,\n        EXTRACT(QUARTER FROM pp.price_effective_date) AS quarter_num,\n        pp.current_price,\n        pp.price_type,\n        COUNT(DISTINCT pp.store_id) AS store_count,\n        COUNT(DISTINCT pp.retailer_id) AS retailer_count\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    WHERE pp.price_effective_date >= CURRENT_DATE - INTERVAL '2 years'\n        AND p.is_active = TRUE\n    GROUP BY p.category, p.subcategory, p.product_id, p.product_name, pp.price_effective_date, pp.current_price, pp.price_type\n),\nmonthly_category_aggregates AS (\n    SELECT\n        category,\n        subcategory,\n        sale_month,\n        month_num,\n        quarter_num,\n        COUNT(DISTINCT product_id) AS products_count,\n        COUNT(DISTINCT retailer_id) AS retailers_count,\n        SUM(store_count) AS total_stores,\n        AVG(current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY current_price) AS median_price,\n        MIN(current_price) AS min_price,\n        MAX(current_price) AS max_price,\n        STDDEV(current_price) AS price_std_dev,\n        COUNT(CASE WHEN price_type = 'sale' THEN 1 END) AS sale_count,\n        COUNT(CASE WHEN price_type = 'clearance' THEN 1 END) AS clearance_count\n    FROM category_sales_base\n    GROUP BY category, subcategory, sale_month, month_num, quarter_num\n),\nseasonal_decomposition AS (\n    SELECT\n        mca.*,\n        AVG(mca.avg_price) OVER (\n            PARTITION BY mca.category, mca.subcategory\n            ORDER BY mca.sale_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        AVG(mca.avg_price) OVER (\n            PARTITION BY mca.category, mca.subcategory, mca.month_num\n        ) AS seasonal_avg_by_month,\n        mca.avg_price - AVG(mca.avg_price) OVER (\n            PARTITION BY mca.category, mca.subcategory, mca.month_num\n        ) AS seasonal_component,\n        LAG(mca.avg_price, 12) OVER (\n            PARTITION BY mca.category, mca.subcategory\n            ORDER BY mca.sale_month\n        ) AS year_ago_price,\n        LEAD(mca.avg_price, 12) OVER (\n            PARTITION BY mca.category, mca.subcategory\n            ORDER BY mca.sale_month\n        ) AS year_ahead_price\n    FROM monthly_category_aggregates mca\n),\ntrend_analysis AS (\n    SELECT\n        sd.*,\n        CASE\n            WHEN sd.year_ago_price IS NOT NULL THEN\n                ((sd.avg_price - sd.year_ago_price) / sd.year_ago_price) * 100\n            ELSE NULL\n        END AS yoy_price_change,\n        AVG(sd.avg_price) OVER (\n            PARTITION BY sd.category, sd.subcategory\n            ORDER BY sd.sale_month\n            ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_3m,\n        STDDEV(sd.avg_price) OVER (\n            PARTITION BY sd.category, sd.subcategory\n            ORDER BY sd.sale_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m,\n        ROW_NUMBER() OVER (\n            PARTITION BY sd.category, sd.subcategory\n            ORDER BY sd.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY sd.category, sd.subcategory\n            ORDER BY sd.avg_price DESC\n        ) AS price_percentile\n    FROM seasonal_decomposition sd\n),\ncategory_performance_metrics AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.yoy_price_change > 5 THEN 'strong_growth'\n            WHEN ta.yoy_price_change > 0 THEN 'moderate_growth'\n            WHEN ta.yoy_price_change > -5 THEN 'stable'\n            WHEN ta.yoy_price_change > -10 THEN 'moderate_decline'\n            ELSE 'strong_decline'\n        END AS trend_classification,\n        CASE\n            WHEN ta.price_volatility_12m < ta.avg_price * 0.1 THEN 'low_volatility'\n            WHEN ta.price_volatility_12m < ta.avg_price * 0.2 THEN 'moderate_volatility'\n            ELSE 'high_volatility'\n        END AS volatility_classification,\n        ta.sale_count + ta.clearance_count AS total_promotions,\n        CASE\n            WHEN ta.sale_count + ta.clearance_count > ta.products_count * 0.5 THEN 'high_promotion'\n            WHEN ta.sale_count + ta.clearance_count > ta.products_count * 0.25 THEN 'moderate_promotion'\n            ELSE 'low_promotion'\n        END AS promotion_level\n    FROM trend_analysis ta\n),\nfinal_category_intelligence AS (\n    SELECT\n        cpm.category,\n        cpm.subcategory,\n        cpm.sale_month,\n        cpm.month_num,\n        cpm.quarter_num,\n        ROUND(CAST(cpm.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(cpm.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(cpm.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(cpm.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(cpm.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(cpm.seasonal_component AS NUMERIC), 2) AS seasonal_component,\n        ROUND(CAST(cpm.yoy_price_change AS NUMERIC), 2) AS yoy_price_change,\n        ROUND(CAST(cpm.moving_avg_3m AS NUMERIC), 2) AS moving_avg_3m,\n        ROUND(CAST(cpm.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        cpm.trend_classification,\n        cpm.volatility_classification,\n        cpm.promotion_level,\n        cpm.products_count,\n        cpm.retailers_count,\n        cpm.total_stores,\n        cpm.sale_count,\n        cpm.clearance_count,\n        cpm.total_promotions\n    FROM category_performance_metrics cpm\n)\nSELECT\n    category,\n    subcategory,\n    sale_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    seasonal_component,\n    yoy_price_change,\n    trend_classification,\n    volatility_classification,\n    promotion_level,\n    products_count,\n    retailers_count,\n    total_promotions\nFROM final_category_intelligence\nWHERE sale_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, sale_month DESC;",
      "line_number": 1084
    },
    {
      "number": 6,
      "title": "Marketing Intelligence Analysis Query 6",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 1261
    },
    {
      "number": 7,
      "title": "Marketing Intelligence Analysis Query 7",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 1436
    },
    {
      "number": 8,
      "title": "Marketing Intelligence Analysis Query 8",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 1612
    },
    {
      "number": 9,
      "title": "Marketing Intelligence Analysis Query 9",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 1788
    },
    {
      "number": 10,
      "title": "Marketing Intelligence Analysis Query 10",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 1964
    },
    {
      "number": 11,
      "title": "Marketing Intelligence Analysis Query 11",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 2140
    },
    {
      "number": 12,
      "title": "Marketing Intelligence Analysis Query 12",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 2316
    },
    {
      "number": 13,
      "title": "Marketing Intelligence Analysis Query 13",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 2492
    },
    {
      "number": 14,
      "title": "Marketing Intelligence Analysis Query 14",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 2668
    },
    {
      "number": 15,
      "title": "Marketing Intelligence Analysis Query 15",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 2844
    },
    {
      "number": 16,
      "title": "Marketing Intelligence Analysis Query 16",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 3020
    },
    {
      "number": 17,
      "title": "Marketing Intelligence Analysis Query 17",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 3196
    },
    {
      "number": 18,
      "title": "Marketing Intelligence Analysis Query 18",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 3372
    },
    {
      "number": 19,
      "title": "Marketing Intelligence Analysis Query 19",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 3548
    },
    {
      "number": 20,
      "title": "Marketing Intelligence Analysis Query 20",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 3724
    },
    {
      "number": 21,
      "title": "Marketing Intelligence Analysis Query 21",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 3900
    },
    {
      "number": 22,
      "title": "Marketing Intelligence Analysis Query 22",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 4076
    },
    {
      "number": 23,
      "title": "Marketing Intelligence Analysis Query 23",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 4252
    },
    {
      "number": 24,
      "title": "Marketing Intelligence Analysis Query 24",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 4428
    },
    {
      "number": 25,
      "title": "Marketing Intelligence Analysis Query 25",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 4604
    },
    {
      "number": 26,
      "title": "Marketing Intelligence Analysis Query 26",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 4780
    },
    {
      "number": 27,
      "title": "Marketing Intelligence Analysis Query 27",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 4956
    },
    {
      "number": 28,
      "title": "Marketing Intelligence Analysis Query 28",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 5132
    },
    {
      "number": 29,
      "title": "Marketing Intelligence Analysis Query 29",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 5308
    },
    {
      "number": 30,
      "title": "Marketing Intelligence Analysis Query 30",
      "description": "Description: Comprehensive marketing intelligence analysis with multiple CTEs, window functions, and complex aggregations. Use Case: Marketing intelligence for retail operations Business Value: Supports $1M+ ARR marketing intelligence platforms Purpose: Provides detailed marketing intelligence analysis Complexity: Multiple CTEs (6+ levels), window functions, complex aggregations Expected Output: Analysis report with comprehensive metrics",
      "complexity": "Multiple CTEs (6+ levels), window functions, complex aggregations",
      "expected_output": "Analysis report with comprehensive metrics",
      "sql": "WITH base_analysis AS (\n    SELECT\n        p.product_id,\n        p.product_name,\n        p.category,\n        p.subcategory,\n        p.brand,\n        pp.pricing_id,\n        pp.retailer_id,\n        pp.current_price,\n        pp.price_effective_date,\n        r.retailer_name,\n        r.retailer_type,\n        s.store_id,\n        s.store_city,\n        s.store_state,\n        pi.stock_level,\n        pi.stock_status,\n        DATE_TRUNC('month', pp.price_effective_date) AS price_month,\n        EXTRACT(MONTH FROM pp.price_effective_date) AS month_num\n    FROM products p\n    INNER JOIN product_pricing pp ON p.product_id = pp.product_id\n    INNER JOIN retailers r ON pp.retailer_id = r.retailer_id\n    LEFT JOIN stores s ON pp.store_id = s.store_id\n    LEFT JOIN product_inventory pi ON p.product_id = pi.product_id AND pp.store_id = pi.store_id\n    WHERE p.is_active = TRUE\n        AND r.retailer_status = 'active'\n        AND pp.price_effective_date >= CURRENT_DATE - INTERVAL '180 days'\n),\naggregated_metrics AS (\n    SELECT\n        ba.category,\n        ba.subcategory,\n        ba.brand,\n        ba.price_month,\n        ba.month_num,\n        COUNT(DISTINCT ba.product_id) AS products_count,\n        COUNT(DISTINCT ba.retailer_id) AS retailers_count,\n        COUNT(DISTINCT ba.store_id) AS stores_count,\n        AVG(ba.current_price) AS avg_price,\n        PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ba.current_price) AS median_price,\n        MIN(ba.current_price) AS min_price,\n        MAX(ba.current_price) AS max_price,\n        STDDEV(ba.current_price) AS price_std_dev,\n        COUNT(CASE WHEN ba.stock_status = 'in_stock' THEN 1 END) AS in_stock_count,\n        COUNT(CASE WHEN ba.stock_status = 'out_of_stock' THEN 1 END) AS out_of_stock_count\n    FROM base_analysis ba\n    GROUP BY ba.category, ba.subcategory, ba.brand, ba.price_month, ba.month_num\n),\ntemporal_analysis AS (\n    SELECT\n        am.*,\n        LAG(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS prev_month_avg_price,\n        LEAD(am.avg_price, 1) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n        ) AS next_month_avg_price,\n        AVG(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS moving_avg_12m,\n        STDDEV(am.avg_price) OVER (\n            PARTITION BY am.category, am.subcategory, am.brand\n            ORDER BY am.price_month\n            ROWS BETWEEN 11 PRECEDING AND CURRENT ROW\n        ) AS price_volatility_12m\n    FROM aggregated_metrics am\n),\ntrend_calculations AS (\n    SELECT\n        ta.*,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL THEN\n                ((ta.avg_price - ta.prev_month_avg_price) / ta.prev_month_avg_price) * 100\n            ELSE NULL\n        END AS mom_price_change,\n        CASE\n            WHEN ta.prev_month_avg_price IS NOT NULL AND ta.prev_month_avg_price != 0 THEN\n                ta.avg_price - ta.prev_month_avg_price\n            ELSE NULL\n        END AS price_change_amount,\n        CASE\n            WHEN ta.in_stock_count > 0 THEN\n                (ta.in_stock_count::NUMERIC / (ta.in_stock_count + ta.out_of_stock_count)::NUMERIC) * 100\n            ELSE 0\n        END AS availability_rate\n    FROM temporal_analysis ta\n),\nmarket_intelligence AS (\n    SELECT\n        tc.*,\n        CASE\n            WHEN tc.mom_price_change > 5 THEN 'strong_increase'\n            WHEN tc.mom_price_change > 0 THEN 'moderate_increase'\n            WHEN tc.mom_price_change > -5 THEN 'stable'\n            WHEN tc.mom_price_change > -10 THEN 'moderate_decrease'\n            ELSE 'strong_decrease'\n        END AS price_trend,\n        CASE\n            WHEN tc.availability_rate >= 80 THEN 'high_availability'\n            WHEN tc.availability_rate >= 50 THEN 'moderate_availability'\n            ELSE 'low_availability'\n        END AS availability_classification,\n        ROW_NUMBER() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_rank,\n        PERCENT_RANK() OVER (\n            PARTITION BY tc.category, tc.subcategory\n            ORDER BY tc.avg_price DESC\n        ) AS price_percentile\n    FROM trend_calculations tc\n),\nfinal_analysis AS (\n    SELECT\n        mi.category,\n        mi.subcategory,\n        mi.brand,\n        mi.price_month,\n        ROUND(CAST(mi.avg_price AS NUMERIC), 2) AS avg_price,\n        ROUND(CAST(mi.median_price AS NUMERIC), 2) AS median_price,\n        ROUND(CAST(mi.min_price AS NUMERIC), 2) AS min_price,\n        ROUND(CAST(mi.max_price AS NUMERIC), 2) AS max_price,\n        ROUND(CAST(mi.moving_avg_12m AS NUMERIC), 2) AS moving_avg_12m,\n        ROUND(CAST(mi.mom_price_change AS NUMERIC), 2) AS mom_price_change,\n        ROUND(CAST(mi.price_volatility_12m AS NUMERIC), 2) AS price_volatility_12m,\n        ROUND(CAST(mi.availability_rate AS NUMERIC), 2) AS availability_rate,\n        mi.price_trend,\n        mi.availability_classification,\n        mi.products_count,\n        mi.retailers_count,\n        mi.stores_count,\n        mi.price_rank,\n        ROUND(CAST(mi.price_percentile * 100 AS NUMERIC), 2) AS price_percentile\n    FROM market_intelligence mi\n)\nSELECT\n    category,\n    subcategory,\n    brand,\n    price_month,\n    avg_price,\n    median_price,\n    moving_avg_12m,\n    mom_price_change,\n    price_trend,\n    availability_rate,\n    availability_classification,\n    products_count,\n    retailers_count,\n    price_percentile\nFROM final_analysis\nWHERE price_month >= CURRENT_DATE - INTERVAL '12 months'\nORDER BY category, subcategory, brand, price_month DESC;",
      "line_number": 5484
    }
  ]
}